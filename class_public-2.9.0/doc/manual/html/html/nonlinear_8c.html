<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CLASS MANUAL: nonlinear.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CLASS MANUAL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('nonlinear_8c.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">nonlinear.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="nonlinear_8h_source.html">nonlinear.h</a>&quot;</code><br />
</div><div class="textblock"><div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Include dependency graph for nonlinear.c:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="nonlinear_8c__incl.png" border="0" usemap="#nonlinear_8c" alt=""/></div>
<map name="nonlinear_8c" id="nonlinear_8c">
<area shape="rect" id="node2" href="nonlinear_8h.html" title="nonlinear.h" alt="" coords="556,79,642,104"/>
<area shape="rect" id="node3" href="primordial_8h.html" title="primordial.h" alt="" coords="512,152,603,177"/>
<area shape="rect" id="node25" href="trigonometric__integrals_8h_source.html" title="trigonometric_integrals.h" alt="" coords="611,225,778,251"/>
<area shape="rect" id="node4" href="perturbations_8h.html" title="perturbations.h" alt="" coords="462,225,573,251"/>
<area shape="rect" id="node5" href="thermodynamics_8h.html" title="thermodynamics.h" alt="" coords="254,299,384,324"/>
<area shape="rect" id="node22" href="evolver__ndf15_8h_source.html" title="evolver_ndf15.h" alt="" coords="526,372,642,397"/>
<area shape="rect" id="node24" href="evolver__rkck_8h_source.html" title="evolver_rkck.h" alt="" coords="436,299,543,324"/>
<area shape="rect" id="node6" href="background_8h.html" title="background.h" alt="" coords="244,372,346,397"/>
<area shape="rect" id="node7" href="common_8h.html" title="common.h" alt="" coords="396,519,479,544"/>
<area shape="rect" id="node17" href="quadrature_8h_source.html" title="quadrature.h" alt="" coords="22,445,119,471"/>
<area shape="rect" id="node19" href="arrays_8h_source.html" title="arrays.h" alt="" coords="260,445,330,471"/>
<area shape="rect" id="node20" href="dei__rkck_8h_source.html" title="dei_rkck.h" alt="" coords="447,445,529,471"/>
<area shape="rect" id="node21" href="parser_8h_source.html" title="parser.h" alt="" coords="353,445,423,471"/>
<area shape="rect" id="node13" href="svnversion_8h_source.html" title="svnversion.h" alt="" coords="533,592,630,617"/>
<area shape="rect" id="node15" href="precisions_8h_source.html" title="precisions.h" alt="" coords="747,592,840,617"/>
<area shape="rect" id="node16" href="precision__macros_8h_source.html" title="precision_macros.h" alt="" coords="725,665,862,691"/>
<area shape="rect" id="node23" href="sparse_8h_source.html" title="sparse.h" alt="" coords="604,445,676,471"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa6ff57e89c74643cb400849c24d8af76"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nonlinear_8c.html#aa6ff57e89c74643cb400849c24d8af76">nonlinear_pk_at_z</a> (struct <a class="el" href="background_8h.html#structbackground">background</a> *pba, struct <a class="el" href="structnonlinear.html">nonlinear</a> *pnl, enum <a class="el" href="primordial_8h.html#af97c57fb2cbf4f53e76a1c0ddfb04322">linear_or_logarithmic</a> mode, enum pk_outputs pk_output, double z, int index_pk, double *out_pk, double *out_pk_ic)</td></tr>
<tr class="separator:aa6ff57e89c74643cb400849c24d8af76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dfbde5ad45b8020b610c6554658b27a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nonlinear_8c.html#a5dfbde5ad45b8020b610c6554658b27a">nonlinear_pk_at_k_and_z</a> (struct <a class="el" href="background_8h.html#structbackground">background</a> *pba, struct <a class="el" href="primordial_8h.html#structprimordial">primordial</a> *ppm, struct <a class="el" href="structnonlinear.html">nonlinear</a> *pnl, enum pk_outputs pk_output, double k, double z, int index_pk, double *out_pk, double *out_pk_ic)</td></tr>
<tr class="separator:a5dfbde5ad45b8020b610c6554658b27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02150ad3bf2796315812201fcc837dee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nonlinear_8c.html#a02150ad3bf2796315812201fcc837dee">nonlinear_pks_at_kvec_and_zvec</a> (struct <a class="el" href="background_8h.html#structbackground">background</a> *pba, struct <a class="el" href="structnonlinear.html">nonlinear</a> *pnl, enum pk_outputs pk_output, double *kvec, int kvec_size, double *zvec, int zvec_size, double *out_pk, double *out_pk_cb)</td></tr>
<tr class="separator:a02150ad3bf2796315812201fcc837dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5cccff4f36fa7218700fb1ae022900"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nonlinear_8c.html#a8f5cccff4f36fa7218700fb1ae022900">nonlinear_pk_tilt_at_k_and_z</a> (struct <a class="el" href="background_8h.html#structbackground">background</a> *pba, struct <a class="el" href="primordial_8h.html#structprimordial">primordial</a> *ppm, struct <a class="el" href="structnonlinear.html">nonlinear</a> *pnl, enum pk_outputs pk_output, double k, double z, int index_pk, double *pk_tilt)</td></tr>
<tr class="separator:a8f5cccff4f36fa7218700fb1ae022900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a186738d00b9c3665df1373f2bddd81b4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nonlinear_8c.html#a186738d00b9c3665df1373f2bddd81b4">nonlinear_sigmas_at_z</a> (struct <a class="el" href="common_8h.html#structprecision">precision</a> *ppr, struct <a class="el" href="background_8h.html#structbackground">background</a> *pba, struct <a class="el" href="structnonlinear.html">nonlinear</a> *pnl, double R, double z, int index_pk, enum out_sigmas sigma_output, double *result)</td></tr>
<tr class="separator:a186738d00b9c3665df1373f2bddd81b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b3f35646d9b27de4910d72d1d7079a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nonlinear_8c.html#a13b3f35646d9b27de4910d72d1d7079a">nonlinear_k_nl_at_z</a> (struct <a class="el" href="background_8h.html#structbackground">background</a> *pba, struct <a class="el" href="structnonlinear.html">nonlinear</a> *pnl, double z, double *k_nl, double *k_nl_cb)</td></tr>
<tr class="separator:a13b3f35646d9b27de4910d72d1d7079a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86727ddb48af0066973966308bb889cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nonlinear_8c.html#a86727ddb48af0066973966308bb889cd">nonlinear_init</a> (struct <a class="el" href="common_8h.html#structprecision">precision</a> *ppr, struct <a class="el" href="background_8h.html#structbackground">background</a> *pba, struct <a class="el" href="thermodynamics_8h.html#structthermo">thermo</a> *pth, struct <a class="el" href="perturbations_8h.html#structperturbs">perturbs</a> *ppt, struct <a class="el" href="primordial_8h.html#structprimordial">primordial</a> *ppm, struct <a class="el" href="structnonlinear.html">nonlinear</a> *pnl)</td></tr>
<tr class="separator:a86727ddb48af0066973966308bb889cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff63e7434268cc98d583f2cd332c948"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nonlinear_8c.html#a9ff63e7434268cc98d583f2cd332c948">nonlinear_free</a> (struct <a class="el" href="structnonlinear.html">nonlinear</a> *pnl)</td></tr>
<tr class="separator:a9ff63e7434268cc98d583f2cd332c948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4509ad8fa2fb707a6ed1def1c44a1599"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nonlinear_8c.html#a4509ad8fa2fb707a6ed1def1c44a1599">nonlinear_indices</a> (struct <a class="el" href="common_8h.html#structprecision">precision</a> *ppr, struct <a class="el" href="background_8h.html#structbackground">background</a> *pba, struct <a class="el" href="perturbations_8h.html#structperturbs">perturbs</a> *ppt, struct <a class="el" href="primordial_8h.html#structprimordial">primordial</a> *ppm, struct <a class="el" href="structnonlinear.html">nonlinear</a> *pnl)</td></tr>
<tr class="separator:a4509ad8fa2fb707a6ed1def1c44a1599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6394e9b5bea0968818e3c8381299663"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nonlinear_8c.html#ad6394e9b5bea0968818e3c8381299663">nonlinear_get_k_list</a> (struct <a class="el" href="common_8h.html#structprecision">precision</a> *ppr, struct <a class="el" href="perturbations_8h.html#structperturbs">perturbs</a> *ppt, struct <a class="el" href="structnonlinear.html">nonlinear</a> *pnl)</td></tr>
<tr class="separator:ad6394e9b5bea0968818e3c8381299663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70d6af2a4ebfc04ddc2a6e608b86fe5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nonlinear_8c.html#ad70d6af2a4ebfc04ddc2a6e608b86fe5">nonlinear_get_tau_list</a> (struct <a class="el" href="perturbations_8h.html#structperturbs">perturbs</a> *ppt, struct <a class="el" href="structnonlinear.html">nonlinear</a> *pnl)</td></tr>
<tr class="separator:ad70d6af2a4ebfc04ddc2a6e608b86fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e79ba2257a5061b0433c2eb343dd86f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nonlinear_8c.html#a8e79ba2257a5061b0433c2eb343dd86f">nonlinear_get_source</a> (struct <a class="el" href="background_8h.html#structbackground">background</a> *pba, struct <a class="el" href="perturbations_8h.html#structperturbs">perturbs</a> *ppt, struct <a class="el" href="structnonlinear.html">nonlinear</a> *pnl, int index_k, int index_ic, int index_tp, int index_tau, double **sources, double *source)</td></tr>
<tr class="separator:a8e79ba2257a5061b0433c2eb343dd86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca0b7e9542e46b712c83830cc013986"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nonlinear_8c.html#aaca0b7e9542e46b712c83830cc013986">nonlinear_pk_linear</a> (struct <a class="el" href="background_8h.html#structbackground">background</a> *pba, struct <a class="el" href="perturbations_8h.html#structperturbs">perturbs</a> *ppt, struct <a class="el" href="primordial_8h.html#structprimordial">primordial</a> *ppm, struct <a class="el" href="structnonlinear.html">nonlinear</a> *pnl, int index_pk, int index_tau, int k_size, double *lnpk, double *lnpk_ic)</td></tr>
<tr class="separator:aaca0b7e9542e46b712c83830cc013986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739a313b3acffe41ee5494e3a5dfa083"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nonlinear_8c.html#a739a313b3acffe41ee5494e3a5dfa083">nonlinear_sigmas</a> (struct <a class="el" href="structnonlinear.html">nonlinear</a> *pnl, double R, double *lnpk_l, double *ddlnpk_l, int k_size, double k_per_decade, enum out_sigmas sigma_output, double *result)</td></tr>
<tr class="separator:a739a313b3acffe41ee5494e3a5dfa083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda6e39f3da0f7d9d33c7d67a720170e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nonlinear_8c.html#afda6e39f3da0f7d9d33c7d67a720170e">nonlinear_sigma_at_z</a> (struct <a class="el" href="background_8h.html#structbackground">background</a> *pba, struct <a class="el" href="structnonlinear.html">nonlinear</a> *pnl, double R, double z, int index_pk, double k_per_decade, double *result)</td></tr>
<tr class="separator:afda6e39f3da0f7d9d33c7d67a720170e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92cd4a12c3a1c7d1a3d935a0d76f7159"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nonlinear_8c.html#a92cd4a12c3a1c7d1a3d935a0d76f7159">nonlinear_halofit</a> (struct <a class="el" href="common_8h.html#structprecision">precision</a> *ppr, struct <a class="el" href="background_8h.html#structbackground">background</a> *pba, struct <a class="el" href="perturbations_8h.html#structperturbs">perturbs</a> *ppt, struct <a class="el" href="primordial_8h.html#structprimordial">primordial</a> *ppm, struct <a class="el" href="structnonlinear.html">nonlinear</a> *pnl, int index_pk, double tau, double *pk_nl, double *lnpk_l, double *ddlnpk_l, double *k_nl, short *nl_corr_not_computable_at_this_k)</td></tr>
<tr class="separator:a92cd4a12c3a1c7d1a3d935a0d76f7159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e5fe7614b870191df0e37a626671fdc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nonlinear_8c.html#a3e5fe7614b870191df0e37a626671fdc">nonlinear_halofit_integrate</a> (struct <a class="el" href="structnonlinear.html">nonlinear</a> *pnl, double *integrand_array, int integrand_size, int ia_size, int index_ia_k, int index_ia_pk, int index_ia_sum, int index_ia_ddsum, double R, enum halofit_integral_type type, double *sum)</td></tr>
<tr class="separator:a3e5fe7614b870191df0e37a626671fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de22a21f1be80af9e1b1d68c11c4a40"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nonlinear_8c.html#a2de22a21f1be80af9e1b1d68c11c4a40">nonlinear_hmcode</a> (struct <a class="el" href="common_8h.html#structprecision">precision</a> *ppr, struct <a class="el" href="background_8h.html#structbackground">background</a> *pba, struct <a class="el" href="perturbations_8h.html#structperturbs">perturbs</a> *ppt, struct <a class="el" href="primordial_8h.html#structprimordial">primordial</a> *ppm, struct <a class="el" href="structnonlinear.html">nonlinear</a> *pnl, int index_pk, int index_tau, double tau, double *pk_nl, double **lnpk_l, double **ddlnpk_l, double *k_nl, short *nl_corr_not_computable_at_this_k, struct <a class="el" href="structnonlinear__workspace.html">nonlinear_workspace</a> *pnw)</td></tr>
<tr class="separator:a2de22a21f1be80af9e1b1d68c11c4a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac165bba7bcf94edf43b6fc948d2f77ac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nonlinear_8c.html#ac165bba7bcf94edf43b6fc948d2f77ac">nonlinear_hmcode_workspace_init</a> (struct <a class="el" href="common_8h.html#structprecision">precision</a> *ppr, struct <a class="el" href="background_8h.html#structbackground">background</a> *pba, struct <a class="el" href="structnonlinear.html">nonlinear</a> *pnl, struct <a class="el" href="structnonlinear__workspace.html">nonlinear_workspace</a> *pnw)</td></tr>
<tr class="separator:ac165bba7bcf94edf43b6fc948d2f77ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c9071fa9080aa10b86ad44a69767d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nonlinear_8c.html#ae0c9071fa9080aa10b86ad44a69767d9">nonlinear_hmcode_workspace_free</a> (struct <a class="el" href="structnonlinear.html">nonlinear</a> *pnl, struct <a class="el" href="structnonlinear__workspace.html">nonlinear_workspace</a> *pnw)</td></tr>
<tr class="separator:ae0c9071fa9080aa10b86ad44a69767d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab36bfbd6e836dfbf8a318e592aeb6f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nonlinear_8c.html#a1ab36bfbd6e836dfbf8a318e592aeb6f">nonlinear_hmcode_dark_energy_correction</a> (struct <a class="el" href="common_8h.html#structprecision">precision</a> *ppr, struct <a class="el" href="background_8h.html#structbackground">background</a> *pba, struct <a class="el" href="structnonlinear.html">nonlinear</a> *pnl, struct <a class="el" href="structnonlinear__workspace.html">nonlinear_workspace</a> *pnw)</td></tr>
<tr class="separator:a1ab36bfbd6e836dfbf8a318e592aeb6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe04c26492e2298841ec3c719aea9a67"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nonlinear_8c.html#abe04c26492e2298841ec3c719aea9a67">nonlinear_hmcode_baryonic_feedback</a> (struct <a class="el" href="structnonlinear.html">nonlinear</a> *pnl)</td></tr>
<tr class="separator:abe04c26492e2298841ec3c719aea9a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c75678b02fffa5267b53fe984f4c22"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nonlinear_8c.html#a14c75678b02fffa5267b53fe984f4c22">nonlinear_hmcode_fill_sigtab</a> (struct <a class="el" href="common_8h.html#structprecision">precision</a> *ppr, struct <a class="el" href="background_8h.html#structbackground">background</a> *pba, struct <a class="el" href="perturbations_8h.html#structperturbs">perturbs</a> *ppt, struct <a class="el" href="primordial_8h.html#structprimordial">primordial</a> *ppm, struct <a class="el" href="structnonlinear.html">nonlinear</a> *pnl, int index_tau, double *lnpk_l, double *ddlnpk_l, struct <a class="el" href="structnonlinear__workspace.html">nonlinear_workspace</a> *pnw)</td></tr>
<tr class="separator:a14c75678b02fffa5267b53fe984f4c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3b2b6204ff32a84a97e3fc869c191d0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nonlinear_8c.html#ae3b2b6204ff32a84a97e3fc869c191d0">nonlinear_hmcode_fill_growtab</a> (struct <a class="el" href="common_8h.html#structprecision">precision</a> *ppr, struct <a class="el" href="background_8h.html#structbackground">background</a> *pba, struct <a class="el" href="structnonlinear.html">nonlinear</a> *pnl, struct <a class="el" href="structnonlinear__workspace.html">nonlinear_workspace</a> *pnw)</td></tr>
<tr class="separator:ae3b2b6204ff32a84a97e3fc869c191d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d34e84b671d40d1ea72d195df2fc4a2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nonlinear_8c.html#a4d34e84b671d40d1ea72d195df2fc4a2">nonlinear_hmcode_growint</a> (struct <a class="el" href="common_8h.html#structprecision">precision</a> *ppr, struct <a class="el" href="background_8h.html#structbackground">background</a> *pba, struct <a class="el" href="structnonlinear.html">nonlinear</a> *pnl, double a, double w0, double wa, double *growth)</td></tr>
<tr class="separator:a4d34e84b671d40d1ea72d195df2fc4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d3624e0e02a0f595a0223515b8e3897"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nonlinear_8c.html#a4d3624e0e02a0f595a0223515b8e3897">nonlinear_hmcode_window_nfw</a> (struct <a class="el" href="structnonlinear.html">nonlinear</a> *pnl, double k, double rv, double c, double *window_nfw)</td></tr>
<tr class="separator:a4d3624e0e02a0f595a0223515b8e3897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f3b694b69d5d5305c5c235da4c6a66"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nonlinear_8c.html#a40f3b694b69d5d5305c5c235da4c6a66">nonlinear_hmcode_halomassfunction</a> (double nu, double *hmf)</td></tr>
<tr class="separator:a40f3b694b69d5d5305c5c235da4c6a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12ee38aa9aa49f69cd0d7308fb88ec9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nonlinear_8c.html#aa12ee38aa9aa49f69cd0d7308fb88ec9">nonlinear_hmcode_sigma8_at_z</a> (struct <a class="el" href="background_8h.html#structbackground">background</a> *pba, struct <a class="el" href="structnonlinear.html">nonlinear</a> *pnl, double z, double *sigma_8, double *sigma_8_cb, struct <a class="el" href="structnonlinear__workspace.html">nonlinear_workspace</a> *pnw)</td></tr>
<tr class="separator:aa12ee38aa9aa49f69cd0d7308fb88ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a92da4b4ebac7ff8e0d220cc4625e1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nonlinear_8c.html#ab4a92da4b4ebac7ff8e0d220cc4625e1">nonlinear_hmcode_sigmadisp_at_z</a> (struct <a class="el" href="background_8h.html#structbackground">background</a> *pba, struct <a class="el" href="structnonlinear.html">nonlinear</a> *pnl, double z, double *sigma_disp, double *sigma_disp_cb, struct <a class="el" href="structnonlinear__workspace.html">nonlinear_workspace</a> *pnw)</td></tr>
<tr class="separator:ab4a92da4b4ebac7ff8e0d220cc4625e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf951dc8e27339630abc1e3f9c4055d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nonlinear_8c.html#acf951dc8e27339630abc1e3f9c4055d3">nonlinear_hmcode_sigmadisp100_at_z</a> (struct <a class="el" href="background_8h.html#structbackground">background</a> *pba, struct <a class="el" href="structnonlinear.html">nonlinear</a> *pnl, double z, double *sigma_disp_100, double *sigma_disp_100_cb, struct <a class="el" href="structnonlinear__workspace.html">nonlinear_workspace</a> *pnw)</td></tr>
<tr class="separator:acf951dc8e27339630abc1e3f9c4055d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75116928f44a754e73f03503079618bc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nonlinear_8c.html#a75116928f44a754e73f03503079618bc">nonlinear_hmcode_sigmaprime_at_z</a> (struct <a class="el" href="background_8h.html#structbackground">background</a> *pba, struct <a class="el" href="structnonlinear.html">nonlinear</a> *pnl, double z, double *sigma_prime, double *sigma_prime_cb, struct <a class="el" href="structnonlinear__workspace.html">nonlinear_workspace</a> *pnw)</td></tr>
<tr class="separator:a75116928f44a754e73f03503079618bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Documented nonlinear module</p>
<p>Julien Lesgourgues, 6.03.2014</p>
<p>New module replacing an older one present up to version 2.0 The new module is located in a better place in the main, allowing it to compute non-linear correction to <img class="formulaInl" alt="$ C_l$" src="form_71.png"/>'s and not just <img class="formulaInl" alt="$ P(k)$" src="form_191.png"/>. It will also be easier to generalize to new methods. The old implementation of one-loop calculations and TRG calculations has been dropped from this version, they can still be found in older versions.</p>
<p>Documented nonlinear module</p>
<p>Julien Lesgourgues, 30.09.2019</p>
<p>New module replacing an older one, present up to version 2.7. The new module takes into account the fact that the linear P(k) must be computed before the non-linear one. So it now contains all the important functions related to the computation of 2-point statistics in Fourier space (P_linear(k,z), sigma(R,z), P_non_linear(k,z), etc.). The one-loop PT and TRG calculations has been dropped from this version, but can still be found in older versions. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="aa6ff57e89c74643cb400849c24d8af76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6ff57e89c74643cb400849c24d8af76">&#9670;&nbsp;</a></span>nonlinear_pk_at_z()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nonlinear_pk_at_z </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="background_8h.html#structbackground">background</a> *&#160;</td>
          <td class="paramname"><em>pba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnonlinear.html">nonlinear</a> *&#160;</td>
          <td class="paramname"><em>pnl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="primordial_8h.html#af97c57fb2cbf4f53e76a1c0ddfb04322">linear_or_logarithmic</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum pk_outputs&#160;</td>
          <td class="paramname"><em>pk_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index_pk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>out_pk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>out_pk_ic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the P(k,z) for a given redshift z and pk type (_m, _cb) (linear if pk_output = pk_linear, nonlinear if pk_output = pk_nonlinear)</p>
<p>In the linear case, if there are several initial conditions <em>and</em> the input pointer out_pk_ic is not set to NULL, the function also returns the decomposition into different IC contributions.</p>
<p>Hints on input index_pk:</p>
<p>a. if you want the total matter spectrum P_m(k,z), pass in input pnl-&gt;index_pk_total (this index is always defined)</p>
<p>b. if you want the power spectrum relevant for galaxy or halos, given by P_cb if there is non-cold-dark-matter (e.g. massive neutrinos) and to P_m otherwise, pass in input pnl-&gt;index_pk_cluster (this index is always defined)</p>
<p>c. there is another possible syntax (use it only if you know what you are doing): if pnl-&gt;has_pk_m == <em>TRUE</em> you may pass pnl-&gt;index_pk_m to get P_m if pnl-&gt;has_pk_cb == <em>TRUE</em> you may pass pnl-&gt;index_pk_cb to get P_cb</p>
<p>Output format:</p>
<ol type="1">
<li>if mode = logarithmic (most straightforward for the code): out_pk = ln(P(k)) out_pk_ic[diagonal] = ln(P_ic(k)) out_pk_ic[non-diagonal] = cos(correlation angle icxic)</li>
<li>if mode = linear (a conversion is done internally in this function) out_pk = P(k) out_pk_ic[diagonal] = P_ic(k) out_pk_ic[non-diagonal] = P_icxic(k)</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pba</td><td>Input: pointer to background structure </td></tr>
    <tr><td class="paramname">pnl</td><td>Input: pointer to nonlinear structure </td></tr>
    <tr><td class="paramname">mode</td><td>Input: linear or logarithmic </td></tr>
    <tr><td class="paramname">pk_output</td><td>Input: linear or nonlinear </td></tr>
    <tr><td class="paramname">z</td><td>Input: redshift </td></tr>
    <tr><td class="paramname">index_pk</td><td>Input: index of pk type (_m, _cb) </td></tr>
    <tr><td class="paramname">out_pk</td><td>Output: P(k) returned as out_pk_l[index_k] </td></tr>
    <tr><td class="paramname">out_pk_ic</td><td>Output: P_ic(k) returned as out_pk_ic[index_k * pnl-&gt;ic_ic_size + index_ic1_ic2] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>
<ul>
<li>check whether we need the decomposition into contributions from each initial condition</li>
<li>case z=0 requiring no interpolation in z</li>
<li>interpolation in z</li>
</ul>
<p>&ndash;&gt; get value of contormal time tau</p>
<p>-&gt; check that tau is in pre-computed table</p>
<p>&ndash;&gt; if ln(tau) much too small, raise an error</p>
<p>&ndash;&gt; if ln(tau) too small but within tolerance, round it and get right values without interpolating</p>
<p>&ndash;&gt; if ln(tau) much too large, raise an error</p>
<p>&ndash;&gt; if ln(tau) too large but within tolerance, round it and get right values without interpolating</p>
<p>-&gt; tau is in pre-computed table: interpolate</p>
<p>&ndash;&gt; interpolate P_l(k) at tau from pre-computed array</p>
<p>&ndash;&gt; interpolate P_ic_l(k) at tau from pre-computed array</p>
<p>&ndash;&gt; interpolate P_nl(k) at tau from pre-computed array</p>
<ul>
<li>so far, all output stored in logarithmic format. Eventually, convert to linear one.</li>
</ul>
<p>&ndash;&gt; loop over k</p>
<p>&ndash;&gt; convert total spectrum</p>
<p>&ndash;&gt; convert contribution of each ic (diagonal elements)</p>
<p>&ndash;&gt; convert contribution of each ic (non-diagonal elements) </p>

</div>
</div>
<a id="a5dfbde5ad45b8020b610c6554658b27a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dfbde5ad45b8020b610c6554658b27a">&#9670;&nbsp;</a></span>nonlinear_pk_at_k_and_z()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nonlinear_pk_at_k_and_z </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="background_8h.html#structbackground">background</a> *&#160;</td>
          <td class="paramname"><em>pba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="primordial_8h.html#structprimordial">primordial</a> *&#160;</td>
          <td class="paramname"><em>ppm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnonlinear.html">nonlinear</a> *&#160;</td>
          <td class="paramname"><em>pnl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum pk_outputs&#160;</td>
          <td class="paramname"><em>pk_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index_pk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>out_pk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>out_pk_ic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the P(k,z) for a given (k,z) and pk type (_m, _cb) (linear if pk_output = pk_linear, nonlinear if pk_output = pk_nonlinear)</p>
<p>In the linear case, if there are several initial conditions <em>and</em> the input pointer out_pk_ic is not set to NULL, the function also returns the decomposition into different IC contributions.</p>
<p>Hints on input index_pk:</p>
<p>a. if you want the total matter spectrum P_m(k,z), pass in input pnl-&gt;index_pk_total (this index is always defined)</p>
<p>b. if you want the power spectrum relevant for galaxy or halos, given by P_cb if there is non-cold-dark-matter (e.g. massive neutrinos) and to P_m otherwise, pass in input pnl-&gt;index_pk_cluster (this index is always defined)</p>
<p>c. there is another possible syntax (use it only if you know what you are doing): if pnl-&gt;has_pk_m == <em>TRUE</em> you may pass pnl-&gt;index_pk_m to get P_m if pnl-&gt;has_pk_cb == <em>TRUE</em> you may pass pnl-&gt;index_pk_cb to get P_cb</p>
<p>Output format: </p><pre class="fragment">out_pk = P(k)
out_pk_ic[diagonal] = P_ic(k)
out_pk_ic[non-diagonal] = P_icxic(k)
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pba</td><td>Input: pointer to background structure </td></tr>
    <tr><td class="paramname">ppm</td><td>Input: pointer to primordial structure </td></tr>
    <tr><td class="paramname">pnl</td><td>Input: pointer to nonlinear structure </td></tr>
    <tr><td class="paramname">pk_output</td><td>Input: linear or nonlinear </td></tr>
    <tr><td class="paramname">k</td><td>Input: wavenumber in 1/Mpc </td></tr>
    <tr><td class="paramname">z</td><td>Input: redshift </td></tr>
    <tr><td class="paramname">index_pk</td><td>Input: index of pk type (_m, _cb) </td></tr>
    <tr><td class="paramname">out_pk</td><td>Output: pointer to P </td></tr>
    <tr><td class="paramname">out_pk_ic</td><td>Ouput: P_ic returned as out_pk_ic_l[index_ic1_ic2] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>
<ul>
<li>preliminary: check whether we need the decomposition into contributions from each initial condition</li>
<li>first step: check that k is in valid range [0:kmax] (the test for z will be done when calling nonlinear_pk_linear_at_z())</li>
<li>deal with case k = 0 for which P(k) is set to zero (this non-physical result can be useful for interpolations)</li>
<li>deal with 0 &lt; k &lt;= kmax</li>
</ul>
<p>&ndash;&gt; First, get P(k) at the right z</p>
<ul>
<li>deal with standard case kmin &lt;= k &lt;= kmax (just need to interpolate at the right k)</li>
</ul>
<p>&ndash;&gt; deal with case 0 &lt; k &lt; kmin that requires extrapolation P(k) = [some number] * k * P_primordial(k) so P(k) = P(kmin) * (k P_primordial(k)) / (kmin P_primordial(kmin)) (note that the result is accurate only if kmin is such that [a0 kmin] &lt;&lt; H0)</p>
<p>This is accurate for the synchronous gauge; TODO: write newtonian gauge case. Also, In presence of isocurvature modes, we assumes for simplicity that the mode with index_ic_ic=0 dominates at small k: exact treatment should be written if needed.</p>

</div>
</div>
<a id="a02150ad3bf2796315812201fcc837dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02150ad3bf2796315812201fcc837dee">&#9670;&nbsp;</a></span>nonlinear_pks_at_kvec_and_zvec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nonlinear_pks_at_kvec_and_zvec </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="background_8h.html#structbackground">background</a> *&#160;</td>
          <td class="paramname"><em>pba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnonlinear.html">nonlinear</a> *&#160;</td>
          <td class="paramname"><em>pnl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum pk_outputs&#160;</td>
          <td class="paramname"><em>pk_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>kvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kvec_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>zvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zvec_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>out_pk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>out_pk_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the P(k,z) for a grid of (k_i,z_j) passed in input, for all available pk types (_m, _cb), either linear or nonlinear depending on input.</p>
<p>If there are several initial conditions, this function is not designed to return individual contributions.</p>
<p>The main goal of this routine is speed. Unlike <a class="el" href="nonlinear_8c.html#a5dfbde5ad45b8020b610c6554658b27a">nonlinear_pk_at_k_and_z()</a>, it performs no extrapolation when an input k_i falls outside the pre-computed range [kmin,kmax]: in that case, it just returns P(k,z)=0 for such a k_i</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pba</td><td>Input: pointer to background structure </td></tr>
    <tr><td class="paramname">pnl</td><td>Input: pointer to nonlinear structure </td></tr>
    <tr><td class="paramname">pk_output</td><td>Input: pk_linear or pk_nonlinear </td></tr>
    <tr><td class="paramname">kvec</td><td>Input: array of wavenumbers in ascending order (in 1/Mpc) </td></tr>
    <tr><td class="paramname">kvec_size</td><td>Input: size of array of wavenumbers </td></tr>
    <tr><td class="paramname">zvec</td><td>Input: array of redshifts in arbitrary order </td></tr>
    <tr><td class="paramname">zvec_size</td><td>Input: size of array of redshifts </td></tr>
    <tr><td class="paramname">out_pk</td><td>Output: P(k_i,z_j) for total matter (if available) in Mpc**3 </td></tr>
    <tr><td class="paramname">out_pk_cb</td><td>Output: P_cb(k_i,z_j) for cdm+baryons (if available) in Mpc**3 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>
<p>Summary:</p>
<ul>
<li>define local variables</li>
<li>Allocate arrays</li>
<li>Construct table of log(P(k_n,z_j)) for pre-computed wavenumbers but requested redshifts:</li>
<li>Spline it for interpolation along k</li>
<li>Construct ln(kvec):</li>
<li>Loop over first k values. If k&lt;kmin, fill output with zeros. If not, go to next step.</li>
<li>Deal with case kmin&lt;=k&lt;=kmax. For better performance, do not loop through kvec, but through pre-computed k values.</li>
</ul>
<p>&ndash;&gt; Loop through k_i's that fall in interval [k_n,k_n+1]</p>
<p>&ndash;&gt; for each of them, perform spine interpolation</p>
<ul>
<li>Loop over possible remaining k values with k &gt; kmax, to fill output with zeros. </li>
</ul>

</div>
</div>
<a id="a8f5cccff4f36fa7218700fb1ae022900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f5cccff4f36fa7218700fb1ae022900">&#9670;&nbsp;</a></span>nonlinear_pk_tilt_at_k_and_z()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nonlinear_pk_tilt_at_k_and_z </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="background_8h.html#structbackground">background</a> *&#160;</td>
          <td class="paramname"><em>pba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="primordial_8h.html#structprimordial">primordial</a> *&#160;</td>
          <td class="paramname"><em>ppm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnonlinear.html">nonlinear</a> *&#160;</td>
          <td class="paramname"><em>pnl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum pk_outputs&#160;</td>
          <td class="paramname"><em>pk_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index_pk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pk_tilt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the logarithmic slope of P(k,z) for a given (k,z), a given pk type (_m, _cb) (computed with linear P_L if pk_output = pk_linear, nonlinear P_NL if pk_output = pk_nonlinear)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pba</td><td>Input: pointer to background structure </td></tr>
    <tr><td class="paramname">ppm</td><td>Input: pointer to primordial structure </td></tr>
    <tr><td class="paramname">pnl</td><td>Input: pointer to nonlinear structure </td></tr>
    <tr><td class="paramname">pk_output</td><td>Input: linear or nonlinear </td></tr>
    <tr><td class="paramname">k</td><td>Input: wavenumber in 1/Mpc </td></tr>
    <tr><td class="paramname">z</td><td>Input: redshift </td></tr>
    <tr><td class="paramname">index_pk</td><td>Input: index of pk type (_m, _cb) </td></tr>
    <tr><td class="paramname">n_eff</td><td>Output: logarithmic slope of P(k,z) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>

</div>
</div>
<a id="a186738d00b9c3665df1373f2bddd81b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a186738d00b9c3665df1373f2bddd81b4">&#9670;&nbsp;</a></span>nonlinear_sigmas_at_z()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nonlinear_sigmas_at_z </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="common_8h.html#structprecision">precision</a> *&#160;</td>
          <td class="paramname"><em>ppr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="background_8h.html#structbackground">background</a> *&#160;</td>
          <td class="paramname"><em>pba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnonlinear.html">nonlinear</a> *&#160;</td>
          <td class="paramname"><em>pnl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index_pk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum out_sigmas&#160;</td>
          <td class="paramname"><em>sigma_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine computes the variance of density fluctuations in a sphere of radius R at redshift z, sigma(R,z), or other similar derived quantitites, for one given pk type (_m, _cb).</p>
<p>The integral is performed until the maximum value of k_max defined in the perturbation module. Here there is not automatic checking that k_max is large enough for the result to be well converged. E.g. to get an accurate sigma8 at R = 8 Mpc/h, the user should pass at least about P_k_max_h/Mpc = 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppr</td><td>Input: pointer to precision structure </td></tr>
    <tr><td class="paramname">pba</td><td>Input: pointer to background structure </td></tr>
    <tr><td class="paramname">pnl</td><td>Input: pointer to nonlinear structure </td></tr>
    <tr><td class="paramname">R</td><td>Input: radius in Mpc </td></tr>
    <tr><td class="paramname">z</td><td>Input: redshift </td></tr>
    <tr><td class="paramname">index_pk</td><td>Input: type of pk (_m, _cb) </td></tr>
    <tr><td class="paramname">sigma_output</td><td>Input: quantity to be computed (sigma, sigma', ...) </td></tr>
    <tr><td class="paramname">result</td><td>Output: result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>
<ul>
<li>allocate temporary array for P(k,z) as a function of k</li>
<li>get P(k,z) as a function of k, for the right z</li>
<li>spline it along k</li>
<li>calll the function computing the sigmas</li>
<li>free allocated arrays </li>
</ul>

</div>
</div>
<a id="a13b3f35646d9b27de4910d72d1d7079a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b3f35646d9b27de4910d72d1d7079a">&#9670;&nbsp;</a></span>nonlinear_k_nl_at_z()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nonlinear_k_nl_at_z </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="background_8h.html#structbackground">background</a> *&#160;</td>
          <td class="paramname"><em>pba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnonlinear.html">nonlinear</a> *&#160;</td>
          <td class="paramname"><em>pnl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>k_nl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>k_nl_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the value of the non-linearity wavenumber k_nl for a given redshift z</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pba</td><td>Input: pointer to background structure </td></tr>
    <tr><td class="paramname">pnl</td><td>Input: pointer to nonlinear structure </td></tr>
    <tr><td class="paramname">z</td><td>Input: redshift </td></tr>
    <tr><td class="paramname">k_nl</td><td>Output: k_nl value </td></tr>
    <tr><td class="paramname">k_nl_cb</td><td>Ouput: k_nl value of the cdm+baryon part only, if there is ncdm </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>
<ul>
<li>convert input redshift into a conformal time</li>
<li>interpolate the precomputed k_nl array at the needed valuetime</li>
<li>if needed, do the same for the baryon part only </li>
</ul>

</div>
</div>
<a id="a86727ddb48af0066973966308bb889cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86727ddb48af0066973966308bb889cd">&#9670;&nbsp;</a></span>nonlinear_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nonlinear_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="common_8h.html#structprecision">precision</a> *&#160;</td>
          <td class="paramname"><em>ppr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="background_8h.html#structbackground">background</a> *&#160;</td>
          <td class="paramname"><em>pba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="thermodynamics_8h.html#structthermo">thermo</a> *&#160;</td>
          <td class="paramname"><em>pth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="perturbations_8h.html#structperturbs">perturbs</a> *&#160;</td>
          <td class="paramname"><em>ppt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="primordial_8h.html#structprimordial">primordial</a> *&#160;</td>
          <td class="paramname"><em>ppm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnonlinear.html">nonlinear</a> *&#160;</td>
          <td class="paramname"><em>pnl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the nonlinear structure, and in particular the nl_corr_density and k_nl interpolation tables.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppr</td><td>Input: pointer to precision structure </td></tr>
    <tr><td class="paramname">pba</td><td>Input: pointer to background structure </td></tr>
    <tr><td class="paramname">pth</td><td>Input: pointer to therodynamics structure </td></tr>
    <tr><td class="paramname">ppt</td><td>Input: pointer to perturbation structure </td></tr>
    <tr><td class="paramname">ppm</td><td>Input: pointer to primordial structure </td></tr>
    <tr><td class="paramname">pnl</td><td>Input/Output: pointer to initialized nonlinear structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>
<ul>
<li>preliminary tests</li>
</ul>
<p>&ndash;&gt; This module only makes sense for dealing with scalar perturbations, so it should do nothing if there are no scalars</p>
<p>&ndash;&gt; Nothing to be done if we don't want the matter power spectrum</p>
<p>&ndash;&gt; check applicability of Halofit and HMcode</p>
<ul>
<li>define indices in nonlinear structure (and allocate some arrays in the structure)</li>
<li>get the linear power spectrum at each time</li>
</ul>
<p>&ndash;&gt; loop over required pk types (_m, _cb)</p>
<p>&ndash;&gt; get the linear power spectrum for this time and this type </p><pre class="fragment"> --&gt; if interpolation of \form#192 will be needed (as a
</pre><p> function of tau), compute array of second derivatives in view of spline interpolation</p>
<ul>
<li>compute and store sigma8 (variance of density fluctuations in spheres of radius 8/h Mpc at z=0, always computed by convention using the linear power spectrum)</li>
<li>get the non-linear power spectrum at each time</li>
</ul>
<p>&ndash;&gt; First deal with the case where non non-linear corrections requested</p>
<p>&ndash;&gt; Then go through common preliminary steps to the HALOFIT and HMcode methods</p>
<p>&ndash;&gt; allocate temporary arrays for spectra at each given time/redshift</p>
<p>&ndash;&gt; Then go through preliminary steps specific to HMcode</p>
<p>&ndash;&gt; Loop over decreasing time/growing redhsift. For each time/redshift, compute P_NL(k,z) using either Halofit or HMcode</p>
<p>&ndash;&gt; fill the array of nonlinear power spectra (only if we are at a late time where P(k) and T(k) are supposed to be stored, i.e., such that z(tau &lt; z_max_pk)</p>
<p>&ndash;&gt; spline the array of nonlinear power spectrum</p>
<p>&ndash;&gt; free the nonlinear workspace</p>
<ul>
<li>if the nl_method could not be identified </li>
</ul>

</div>
</div>
<a id="a9ff63e7434268cc98d583f2cd332c948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ff63e7434268cc98d583f2cd332c948">&#9670;&nbsp;</a></span>nonlinear_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nonlinear_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnonlinear.html">nonlinear</a> *&#160;</td>
          <td class="paramname"><em>pnl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free all memory space allocated by <a class="el" href="nonlinear_8c.html#a86727ddb48af0066973966308bb889cd">nonlinear_init()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pnl</td><td>Input: pointer to nonlineard structure (to be freed) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>

</div>
</div>
<a id="a4509ad8fa2fb707a6ed1def1c44a1599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4509ad8fa2fb707a6ed1def1c44a1599">&#9670;&nbsp;</a></span>nonlinear_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nonlinear_indices </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="common_8h.html#structprecision">precision</a> *&#160;</td>
          <td class="paramname"><em>ppr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="background_8h.html#structbackground">background</a> *&#160;</td>
          <td class="paramname"><em>pba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="perturbations_8h.html#structperturbs">perturbs</a> *&#160;</td>
          <td class="paramname"><em>ppt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="primordial_8h.html#structprimordial">primordial</a> *&#160;</td>
          <td class="paramname"><em>ppm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnonlinear.html">nonlinear</a> *&#160;</td>
          <td class="paramname"><em>pnl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Define indices in the nonlinear array, and when possible, allocate arrays in this structure given the index sizes found here</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppr</td><td>Input: pointer to precision structure </td></tr>
    <tr><td class="paramname">pba</td><td>Input: pointer to background structure </td></tr>
    <tr><td class="paramname">ppt</td><td>Input: pointer to perturbation structure </td></tr>
    <tr><td class="paramname">ppm</td><td>Input: pointer to primordial structure </td></tr>
    <tr><td class="paramname">pnl</td><td>Input/Output: pointer to nonlinear structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>
<ul>
<li>define indices for initial conditions (and allocate related arrays)<ul>
<li>define flags indices for pk types (_m, _cb). Note: due to some dependencies in HMcode, when pnl-&gt;index_pk_cb exists, it must come first (e.g. the calculation of the non-linear P_m depends on sigma_cb so the cb-related quantitites must be evaluated first)</li>
</ul>
</li>
<li>get list of k values</li>
<li>get list of tau values</li>
<li>given previous indices, we can allocate the array of linear power spectrum values<ul>
<li>if interpolation of <img class="formulaInl" alt="$P(k,\tau)$" src="form_192.png"/> will be needed (as a function of tau), compute also the array of second derivatives in view of spline interpolation</li>
</ul>
</li>
<li>array of sigma8 values</li>
<li>if non-linear computations needed, allocate array of non-linear correction ratio R_nl(k,z), k_nl(z) and P_nl(k,z) for each P(k) type </li>
</ul>

</div>
</div>
<a id="ad6394e9b5bea0968818e3c8381299663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6394e9b5bea0968818e3c8381299663">&#9670;&nbsp;</a></span>nonlinear_get_k_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nonlinear_get_k_list </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="common_8h.html#structprecision">precision</a> *&#160;</td>
          <td class="paramname"><em>ppr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="perturbations_8h.html#structperturbs">perturbs</a> *&#160;</td>
          <td class="paramname"><em>ppt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnonlinear.html">nonlinear</a> *&#160;</td>
          <td class="paramname"><em>pnl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy list of k from perturbation module, and extended it if necessary to larger k for extrapolation (currently this extrapolation is required only by HMcode)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppr</td><td>Input: pointer to precision structure </td></tr>
    <tr><td class="paramname">ppt</td><td>Input: pointer to perturbation structure </td></tr>
    <tr><td class="paramname">pnl</td><td>Input/Output: pointer to nonlinear structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>
<ul>
<li>if k extrapolation necessary, compute number of required extra values</li>
<li>otherwise, same number of values as in perturbation module</li>
<li>allocate array of k</li>
<li>fill array of k (not extrapolated)</li>
<li>fill additional values of k (extrapolated) </li>
</ul>

</div>
</div>
<a id="ad70d6af2a4ebfc04ddc2a6e608b86fe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad70d6af2a4ebfc04ddc2a6e608b86fe5">&#9670;&nbsp;</a></span>nonlinear_get_tau_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nonlinear_get_tau_list </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="perturbations_8h.html#structperturbs">perturbs</a> *&#160;</td>
          <td class="paramname"><em>ppt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnonlinear.html">nonlinear</a> *&#160;</td>
          <td class="paramname"><em>pnl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy list of tau from perturbation module</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppt</td><td>Input: pointer to perturbation structure </td></tr>
    <tr><td class="paramname">pnl</td><td>Input/Output: pointer to nonlinear structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>
<p>-&gt; for linear calculations: only late times are considered, given the value z_max_pk inferred from the ionput</p>
<p>-&gt; for non-linear calculations: we wills store a correction factor for all times </p>

</div>
</div>
<a id="a8e79ba2257a5061b0433c2eb343dd86f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e79ba2257a5061b0433c2eb343dd86f">&#9670;&nbsp;</a></span>nonlinear_get_source()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nonlinear_get_source </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="background_8h.html#structbackground">background</a> *&#160;</td>
          <td class="paramname"><em>pba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="perturbations_8h.html#structperturbs">perturbs</a> *&#160;</td>
          <td class="paramname"><em>ppt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnonlinear.html">nonlinear</a> *&#160;</td>
          <td class="paramname"><em>pnl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index_k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index_ic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index_tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index_tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get sources for a given wavenumber (and for a given time, type, ic, mode...) either directly from precomputed valkues (computed ain perturbation module), or by analytic extrapolation</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pba</td><td>Input: pointer to background structure </td></tr>
    <tr><td class="paramname">ppt</td><td>Input: pointer to perturbation structure </td></tr>
    <tr><td class="paramname">pnl</td><td>Input: pointer to nonlinear structure </td></tr>
    <tr><td class="paramname">index_k</td><td>Input: index of required k value </td></tr>
    <tr><td class="paramname">index_ic</td><td>Input: index of required ic value </td></tr>
    <tr><td class="paramname">index_tp</td><td>Input: index of required tp value </td></tr>
    <tr><td class="paramname">index_tau</td><td>Input: index of required tau value </td></tr>
    <tr><td class="paramname">sources</td><td>Input: array containing the original sources </td></tr>
    <tr><td class="paramname">source</td><td>Output: desired value of source </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>
<ul>
<li>use precomputed values</li>
<li>extrapolate</li>
</ul>
<p>&ndash;&gt; Get last source and k, which are used in (almost) all methods</p>
<p>&ndash;&gt; Get previous source and k, which are used in best methods</p>
<p>&ndash;&gt; Extrapolate by assuming the source to vanish Has terrible discontinuity</p>
<p>&ndash;&gt; Extrapolate starting from the maximum value, assuming growth ~ ln(k) Has a terrible bend in log slope, discontinuity only in derivative</p>
<p>&ndash;&gt; Extrapolate starting from the maximum value, assuming growth ~ ln(k) Here we use k in h/Mpc instead of 1/Mpc as it is done in the CAMB implementation of HMcode Has a terrible bend in log slope, discontinuity only in derivative</p>
<p>&ndash;&gt; Extrapolate assuming source ~ ln(a*k) where a is obtained from the data at k_0 Mostly continuous derivative, quite good</p>
<p>&ndash;&gt; Extrapolate assuming source ~ ln(e+a*k) where a is estimated like is done in original HMCode</p>
<p>&ndash;&gt; If the user has a complicated model and wants to interpolate differently, they can define their interpolation here and switch to using it instead</p>

</div>
</div>
<a id="aaca0b7e9542e46b712c83830cc013986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaca0b7e9542e46b712c83830cc013986">&#9670;&nbsp;</a></span>nonlinear_pk_linear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nonlinear_pk_linear </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="background_8h.html#structbackground">background</a> *&#160;</td>
          <td class="paramname"><em>pba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="perturbations_8h.html#structperturbs">perturbs</a> *&#160;</td>
          <td class="paramname"><em>ppt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="primordial_8h.html#structprimordial">primordial</a> *&#160;</td>
          <td class="paramname"><em>ppm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnonlinear.html">nonlinear</a> *&#160;</td>
          <td class="paramname"><em>pnl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index_pk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index_tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>lnpk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>lnpk_ic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine computes all the components of the matter power spectrum P(k), given the source functions and the primordial spectra, at a given time within the pre-computed table of sources (= Fourier transfer functions) of the perturbation module, for a given type (total matter _m or baryon+CDM _cb), and for the same array of k values as in the pre-computed table.</p>
<p>If the input array of k values pnl-&gt;ln_k contains wavemumbers larger than those of the pre-computed table, the sources will be extrapolated analytically.</p>
<p>On the opther hand, if the primordial spectrum has sharp features and needs to be sampled on a finer grid than the sources, this function has to be modified to capture the features.</p>
<p>There are two output arrays, because we consider:</p>
<ul>
<li>the total matter (_m) or CDM+baryon (_cb) power spectrum</li>
<li>in the quantitites labelled _ic, the splitting of one of these spectra in different modes for different initial conditions. If the pointer ln_pk_ic is NULL in input, the function will ignore this part; thus, to get the result, one should allocate the array before calling the function. Then the convention is the following:</li>
</ul>
<p>&ndash; the index_ic1_ic2 labels ordered pairs (index_ic1, index_ic2) (since the primordial spectrum is symmetric in (index_ic1, index_ic2)).</p>
<p>&ndash; for diagonal elements (index_ic1 = index_ic2) this arrays contains ln[P(k)] where P(k) is positive by construction.</p>
<p>&ndash; for non-diagonal elements this arrays contains the k-dependent cosine of the correlation angle, namely P(k)_(index_ic1, index_ic2)/sqrt[P(k)_index_ic1 P(k)_index_ic2]. E.g. for fully correlated or anti-correlated initial conditions, this non-diagonal element is independent on k, and equal to +1 or -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pba</td><td>Input: pointer to background structure </td></tr>
    <tr><td class="paramname">ppt</td><td>Input: pointer to perturbation structure </td></tr>
    <tr><td class="paramname">ppm</td><td>Input: pointer to primordial structure </td></tr>
    <tr><td class="paramname">pnl</td><td>Input: pointer to nonlinear structure </td></tr>
    <tr><td class="paramname">index_pk</td><td>Input: index of required P(k) type (_m, _cb) </td></tr>
    <tr><td class="paramname">index_tau</td><td>Input: index of time </td></tr>
    <tr><td class="paramname">k_size</td><td>Input: wavenumber array size </td></tr>
    <tr><td class="paramname">lnpk</td><td>Output: log of matter power spectrum for given type/time, for all wavenumbers </td></tr>
    <tr><td class="paramname">lnpk_ic</td><td>Output: log of matter power spectrum for given type/time, for all wavenumbers and initial conditions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>
<ul>
<li>allocate temporary vector where the primordial spectrum will be stored</li>
<li>loop over k values</li>
</ul>
<p>&ndash;&gt; get primordial spectrum</p>
<p>&ndash;&gt; initialize a local variable for P_m(k) and P_cb(k) to zero</p>
<p>&ndash;&gt; here we recall the relations relevant for the nomalization fo the power spectrum: For adiabatic modes, the curvature primordial spectrum thnat we just read was: P_R(k) = 1/(2pi^2) k^3 &lt;R r&gt;=""&gt; Thus the primordial curvature correlator is given by: &lt;R r&gt;=""&gt; = (2pi^2) k^-3 P_R(k) So the delta_m correlator reads: P(k) = &lt;delta_m delta_m&gt;=""&gt; = (source_m)^2 &lt;R r&gt;=""&gt; = (2pi^2) k^-3 (source_m)^2 P_R(k)</p>
<p>For isocurvature or cross adiabatic-isocurvature parts, one would just replace one or two 'R' by 'S_i's</p>
<p>&ndash;&gt; get contributions to P(k) diagonal in the initial conditions</p>
<p>&ndash;&gt; get contributions to P(k) non-diagonal in the initial conditions </p>

</div>
</div>
<a id="a739a313b3acffe41ee5494e3a5dfa083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a739a313b3acffe41ee5494e3a5dfa083">&#9670;&nbsp;</a></span>nonlinear_sigmas()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nonlinear_sigmas </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnonlinear.html">nonlinear</a> *&#160;</td>
          <td class="paramname"><em>pnl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>lnpk_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ddlnpk_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>k_per_decade</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum out_sigmas&#160;</td>
          <td class="paramname"><em>sigma_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate intermediate quantities for hmcode (sigma, sigma', ...) for a given scale R and a given input P(k).</p>
<p>This function has several differences w.r.t. the standard external function non_linear_sigma (format of input, of output, integration stepsize, management of extrapolation at large k, ...) and is overall more precise for sigma(R).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pnl</td><td>Input: pointer to nonlinear structure </td></tr>
    <tr><td class="paramname">R</td><td>Input: scale at which to compute sigma </td></tr>
    <tr><td class="paramname">lnpk_l</td><td>Input: array of ln(P(k)) </td></tr>
    <tr><td class="paramname">ddlnpk_l</td><td>Input: its spline along k </td></tr>
    <tr><td class="paramname">k_size</td><td>Input: dimension of array lnpk_l, normally pnl-&gt;k_size, but inside hmcode it its increased by extrapolation to pnl-&gt;k_extra_size </td></tr>
    <tr><td class="paramname">k_per_decade</td><td>Input: logarithmic step for the integral (recommended: pass ppr-&gt;sigma_k_per_decade) </td></tr>
    <tr><td class="paramname">sigma_output</td><td>Input: quantity to be computed (sigma, sigma', ...) </td></tr>
    <tr><td class="paramname">result</td><td>Output: result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>
<ul>
<li>allocate temporary array for an integral over y(x)</li>
<li>fill the array with values of k and of the integrand</li>
<li>spline the integrand</li>
<li>integrate</li>
<li>preperly normalize the final result</li>
<li>free allocated array </li>
</ul>

</div>
</div>
<a id="afda6e39f3da0f7d9d33c7d67a720170e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afda6e39f3da0f7d9d33c7d67a720170e">&#9670;&nbsp;</a></span>nonlinear_sigma_at_z()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nonlinear_sigma_at_z </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="background_8h.html#structbackground">background</a> *&#160;</td>
          <td class="paramname"><em>pba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnonlinear.html">nonlinear</a> *&#160;</td>
          <td class="paramname"><em>pnl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index_pk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>k_per_decade</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine computes the variance of density fluctuations in a sphere of radius R at redshift z, sigma(R,z) for one given pk type (_m, _cb).</p>
<p>Try to use instead <a class="el" href="nonlinear_8c.html#a186738d00b9c3665df1373f2bddd81b4">nonlinear_sigmas_at_z()</a>. This function is just maintained for compatibility with the deprecated function <a class="el" href="spectra_8c.html#aad251bcc29d8eee1448d01e30260eb4a">spectra_sigma()</a></p>
<p>The integral is performed until the maximum value of k_max defined in the perturbation module. Here there is not automatic checking that k_max is large enough for the result to be well converged. E.g. to get an accurate sigma8 at R = 8 Mpc/h, the user should pass at least about P_k_max_h/Mpc = 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pba</td><td>Input: pointer to background structure </td></tr>
    <tr><td class="paramname">pnl</td><td>Input: pointer to nonlinear structure </td></tr>
    <tr><td class="paramname">R</td><td>Input: radius in Mpc </td></tr>
    <tr><td class="paramname">z</td><td>Input: redshift </td></tr>
    <tr><td class="paramname">index_pk</td><td>Input: type of pk (_m, _cb) </td></tr>
    <tr><td class="paramname">k_per_decade</td><td>Input: logarithmic step for the integral (recommended: pass ppr-&gt;sigma_k_per_decade) </td></tr>
    <tr><td class="paramname">result</td><td>Output: result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>
<ul>
<li>allocate temporary array for P(k,z) as a function of k</li>
<li>get P(k,z) as a function of k, for the right z</li>
<li>spline it along k</li>
<li>calll the function computing the sigmas</li>
<li>free allocated arrays </li>
</ul>

</div>
</div>
<a id="a92cd4a12c3a1c7d1a3d935a0d76f7159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92cd4a12c3a1c7d1a3d935a0d76f7159">&#9670;&nbsp;</a></span>nonlinear_halofit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nonlinear_halofit </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="common_8h.html#structprecision">precision</a> *&#160;</td>
          <td class="paramname"><em>ppr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="background_8h.html#structbackground">background</a> *&#160;</td>
          <td class="paramname"><em>pba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="perturbations_8h.html#structperturbs">perturbs</a> *&#160;</td>
          <td class="paramname"><em>ppt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="primordial_8h.html#structprimordial">primordial</a> *&#160;</td>
          <td class="paramname"><em>ppm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnonlinear.html">nonlinear</a> *&#160;</td>
          <td class="paramname"><em>pnl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index_pk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pk_nl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>lnpk_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ddlnpk_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>k_nl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short *&#160;</td>
          <td class="paramname"><em>nl_corr_not_computable_at_this_k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculation of the nonlinear matter power spectrum with Halofit (includes Takahashi 2012 + Bird 2013 revisions).</p>
<p>At high redshift it is possible that the non-linear corrections are so small that they can be computed only by going to very large wavenumbers. Thius, for some combination of (z, k_max), the calculation is not possible. In this case a <em>FALSE</em> will be returned in the flag halofit_found_k_max.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppr</td><td>Input: pointer to precision structure </td></tr>
    <tr><td class="paramname">pba</td><td>Input: pointer to background structure </td></tr>
    <tr><td class="paramname">ppt</td><td>Input: pointer to perturbation structure </td></tr>
    <tr><td class="paramname">ppm</td><td>Input: pointer to primordial structure </td></tr>
    <tr><td class="paramname">pnl</td><td>Input: pointer to nonlinear structure </td></tr>
    <tr><td class="paramname">index_pk</td><td>Input: index of component are we looking at (total matter or cdm+baryons?) </td></tr>
    <tr><td class="paramname">tau</td><td>Input: conformal time at which we want to do the calculation </td></tr>
    <tr><td class="paramname">pk_nl</td><td>Output: non linear spectrum at the relevant time </td></tr>
    <tr><td class="paramname">lnpk_l</td><td>Input: array of log(P(k)_linear) </td></tr>
    <tr><td class="paramname">ddlnpk_l</td><td>Input: array of second derivative of log(P(k)_linear) wrt k, for spline interpolation </td></tr>
    <tr><td class="paramname">k_nl</td><td>Output: non-linear wavenumber </td></tr>
    <tr><td class="paramname">nl_corr_not_computable_at_this_k</td><td>Ouput: flag concerning the status of the calculation (<em>TRUE</em> if not possible) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>
<p>Determine non linear ratios (from pk) </p>

</div>
</div>
<a id="a3e5fe7614b870191df0e37a626671fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e5fe7614b870191df0e37a626671fdc">&#9670;&nbsp;</a></span>nonlinear_halofit_integrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nonlinear_halofit_integrate </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnonlinear.html">nonlinear</a> *&#160;</td>
          <td class="paramname"><em>pnl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>integrand_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>integrand_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ia_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index_ia_k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index_ia_pk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index_ia_sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index_ia_ddsum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum halofit_integral_type&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>sum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Internal routione of Halofit. In original Halofit, this is equivalent to the function wint(). It performs convolutions of the linear spectrum with two window functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pnl</td><td>Input: pointer to non linear structure </td></tr>
    <tr><td class="paramname">integrand_array</td><td>Input: array with k, P_L(k) values </td></tr>
    <tr><td class="paramname">integrand_size</td><td>Input: one dimension of that array </td></tr>
    <tr><td class="paramname">ia_size</td><td>Input: other dimension of that array </td></tr>
    <tr><td class="paramname">index_ia_k</td><td>Input: index for k </td></tr>
    <tr><td class="paramname">index_ia_pk</td><td>Input: index for pk </td></tr>
    <tr><td class="paramname">index_ia_sum</td><td>Input: index for the result </td></tr>
    <tr><td class="paramname">index_ia_ddsum</td><td>Input: index for its spline </td></tr>
    <tr><td class="paramname">R</td><td>Input: radius </td></tr>
    <tr><td class="paramname">type</td><td>Input: which window function to use </td></tr>
    <tr><td class="paramname">sum</td><td>Output: result of the integral </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>

</div>
</div>
<a id="a2de22a21f1be80af9e1b1d68c11c4a40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2de22a21f1be80af9e1b1d68c11c4a40">&#9670;&nbsp;</a></span>nonlinear_hmcode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nonlinear_hmcode </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="common_8h.html#structprecision">precision</a> *&#160;</td>
          <td class="paramname"><em>ppr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="background_8h.html#structbackground">background</a> *&#160;</td>
          <td class="paramname"><em>pba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="perturbations_8h.html#structperturbs">perturbs</a> *&#160;</td>
          <td class="paramname"><em>ppt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="primordial_8h.html#structprimordial">primordial</a> *&#160;</td>
          <td class="paramname"><em>ppm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnonlinear.html">nonlinear</a> *&#160;</td>
          <td class="paramname"><em>pnl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index_pk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index_tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>pk_nl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>lnpk_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>ddlnpk_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>k_nl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short *&#160;</td>
          <td class="paramname"><em>nl_corr_not_computable_at_this_k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnonlinear__workspace.html">nonlinear_workspace</a> *&#160;</td>
          <td class="paramname"><em>pnw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the nonlinear correction on the linear power spectrum via the method presented in Mead et al. 1505.07833</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppr</td><td>Input: pointer to precision structure </td></tr>
    <tr><td class="paramname">pba</td><td>Input: pointer to background structure </td></tr>
    <tr><td class="paramname">ppt</td><td>Input: pointer to perturbation structure </td></tr>
    <tr><td class="paramname">ppm</td><td>Input: pointer to primordial structure </td></tr>
    <tr><td class="paramname">pnl</td><td>Input: pointer to nonlinear structure </td></tr>
    <tr><td class="paramname">index_pk</td><td>Input: index of the pk type, either index_m or index_cb </td></tr>
    <tr><td class="paramname">index_tau</td><td>Input: index of tau, at which to compute the nl correction </td></tr>
    <tr><td class="paramname">tau</td><td>Input: tau, at which to compute the nl correction </td></tr>
    <tr><td class="paramname">pk_nl</td><td>Output:nonlinear power spectrum </td></tr>
    <tr><td class="paramname">lnpk_l</td><td>Input: logarithm of the linear power spectrum for both index_m and index_cb </td></tr>
    <tr><td class="paramname">ddlnpk_l</td><td>Input: spline of the logarithm of the linear power spectrum for both index_m and index_cb </td></tr>
    <tr><td class="paramname">nl_corr_not_computable_at_this_k</td><td>Ouput: was the computation doable? </td></tr>
    <tr><td class="paramname">k_nl</td><td>Output: nonlinear scale for index_m and index_cb </td></tr>
    <tr><td class="paramname">pnw</td><td>Input/Output: pointer to nonlinear workspace </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>
<p>include precision parameters that control the number of entries in the growth and sigma tables</p>
<p>Compute background quantitites today</p>
<p>If index_pk_cb, choose Omega0_cb as the matter density parameter. If index_pk_m, choose Omega0_cbn as the matter density parameter.</p>
<p>Call all the relevant background parameters at this tau</p>
<p>Test whether pk_cb has to be taken into account (only if we have massive neutrinos)</p>
<p>Get sigma(R=8 Mpc/h), sigma_disp(R=0), sigma_disp(R=100 Mpc/h) and write them into pnl structure</p>
<p>Initialisation steps for the 1-Halo Power Integral</p>
<p>find nonlinear scales k_nl and r_nl and the effective spectral index n_eff</p>
<p>Calculate halo concentration-mass relation conc(mass) (Bullock et al. 2001)</p>
<p>Compute the nonlinear correction </p>

</div>
</div>
<a id="ac165bba7bcf94edf43b6fc948d2f77ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac165bba7bcf94edf43b6fc948d2f77ac">&#9670;&nbsp;</a></span>nonlinear_hmcode_workspace_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nonlinear_hmcode_workspace_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="common_8h.html#structprecision">precision</a> *&#160;</td>
          <td class="paramname"><em>ppr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="background_8h.html#structbackground">background</a> *&#160;</td>
          <td class="paramname"><em>pba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnonlinear.html">nonlinear</a> *&#160;</td>
          <td class="paramname"><em>pnl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnonlinear__workspace.html">nonlinear_workspace</a> *&#160;</td>
          <td class="paramname"><em>pnw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>allocate and fill arrays of nonlinear workspace (currently used only by HMcode)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppr</td><td>Input: pointer to precision structure </td></tr>
    <tr><td class="paramname">pba</td><td>Input: pointer to background structure </td></tr>
    <tr><td class="paramname">pnl</td><td>Input: pointer to nonlinear structure </td></tr>
    <tr><td class="paramname">pnw</td><td>Output: pointer to nonlinear workspace </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>
<ul>
<li>allocate arrays of the nonlinear workspace</li>
<li>fill table with scale independent growth factor </li>
</ul>

</div>
</div>
<a id="ae0c9071fa9080aa10b86ad44a69767d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c9071fa9080aa10b86ad44a69767d9">&#9670;&nbsp;</a></span>nonlinear_hmcode_workspace_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nonlinear_hmcode_workspace_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnonlinear.html">nonlinear</a> *&#160;</td>
          <td class="paramname"><em>pnl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnonlinear__workspace.html">nonlinear_workspace</a> *&#160;</td>
          <td class="paramname"><em>pnw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>deallocate arrays in the nonlinear worksapce (currently used only by HMcode)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pnl</td><td>Input: pointer to nonlinear structure </td></tr>
    <tr><td class="paramname">pnw</td><td>Input: pointer to nonlinear workspace </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>

</div>
</div>
<a id="a1ab36bfbd6e836dfbf8a318e592aeb6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab36bfbd6e836dfbf8a318e592aeb6f">&#9670;&nbsp;</a></span>nonlinear_hmcode_dark_energy_correction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nonlinear_hmcode_dark_energy_correction </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="common_8h.html#structprecision">precision</a> *&#160;</td>
          <td class="paramname"><em>ppr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="background_8h.html#structbackground">background</a> *&#160;</td>
          <td class="paramname"><em>pba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnonlinear.html">nonlinear</a> *&#160;</td>
          <td class="paramname"><em>pnl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnonlinear__workspace.html">nonlinear_workspace</a> *&#160;</td>
          <td class="paramname"><em>pnw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set the HMcode dark energy correction (if w is not -1)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppr</td><td>Input: pointer to precision structure </td></tr>
    <tr><td class="paramname">pba</td><td>Input: pointer to background structure </td></tr>
    <tr><td class="paramname">pnl</td><td>Input: pointer to nonlinear structure </td></tr>
    <tr><td class="paramname">pnw</td><td>Output: pointer to nonlinear workspace </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>
<ul>
<li>if there is dynamical Dark Energy (w is not -1) modeled as a fluid</li>
<li>otherwise, we assume no dynamical Dark Energy (w is -1) </li>
</ul>

</div>
</div>
<a id="abe04c26492e2298841ec3c719aea9a67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe04c26492e2298841ec3c719aea9a67">&#9670;&nbsp;</a></span>nonlinear_hmcode_baryonic_feedback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nonlinear_hmcode_baryonic_feedback </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnonlinear.html">nonlinear</a> *&#160;</td>
          <td class="paramname"><em>pnl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set the HMcode baryonic feedback parameters according to the chosen feedback model</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pnl</td><td>Output: pointer to nonlinear structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>

</div>
</div>
<a id="a14c75678b02fffa5267b53fe984f4c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14c75678b02fffa5267b53fe984f4c22">&#9670;&nbsp;</a></span>nonlinear_hmcode_fill_sigtab()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nonlinear_hmcode_fill_sigtab </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="common_8h.html#structprecision">precision</a> *&#160;</td>
          <td class="paramname"><em>ppr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="background_8h.html#structbackground">background</a> *&#160;</td>
          <td class="paramname"><em>pba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="perturbations_8h.html#structperturbs">perturbs</a> *&#160;</td>
          <td class="paramname"><em>ppt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="primordial_8h.html#structprimordial">primordial</a> *&#160;</td>
          <td class="paramname"><em>ppm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnonlinear.html">nonlinear</a> *&#160;</td>
          <td class="paramname"><em>pnl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index_tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>lnpk_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ddlnpk_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnonlinear__workspace.html">nonlinear_workspace</a> *&#160;</td>
          <td class="paramname"><em>pnw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function that fills pnw-&gt;rtab, pnw-&gt;stab and pnw-&gt;ddstab with (r, sigma, ddsigma) logarithmically spaced in r. Called by nonlinear_init at for all tau to account for scale-dependant growth before nonlinear_hmcode is called</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppr</td><td>Input: pointer to precision structure </td></tr>
    <tr><td class="paramname">pba</td><td>Input: pointer to background structure </td></tr>
    <tr><td class="paramname">ppt</td><td>Input: pointer to perturbation structure </td></tr>
    <tr><td class="paramname">ppm</td><td>Input: pointer to primordial structure </td></tr>
    <tr><td class="paramname">pnl</td><td>Input: pointer to nonlinear structure </td></tr>
    <tr><td class="paramname">index_tau</td><td>Input: index of tau, at which to compute the nl correction </td></tr>
    <tr><td class="paramname">lnpk_l</td><td>Input: logarithm of the linear power spectrum for either index_m or index_cb </td></tr>
    <tr><td class="paramname">ddlnpk_l</td><td>Input: spline of the logarithm of the linear power spectrum for either index_m or index_cb </td></tr>
    <tr><td class="paramname">pnw</td><td>Output: pointer to nonlinear workspace </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>

</div>
</div>
<a id="ae3b2b6204ff32a84a97e3fc869c191d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3b2b6204ff32a84a97e3fc869c191d0">&#9670;&nbsp;</a></span>nonlinear_hmcode_fill_growtab()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nonlinear_hmcode_fill_growtab </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="common_8h.html#structprecision">precision</a> *&#160;</td>
          <td class="paramname"><em>ppr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="background_8h.html#structbackground">background</a> *&#160;</td>
          <td class="paramname"><em>pba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnonlinear.html">nonlinear</a> *&#160;</td>
          <td class="paramname"><em>pnl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnonlinear__workspace.html">nonlinear_workspace</a> *&#160;</td>
          <td class="paramname"><em>pnw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function that fills pnw-&gt;tautable and pnw-&gt;growtable with (tau, D(tau)) linearly spaced in scalefactor a. Called by nonlinear_init at before the loop over tau</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppr</td><td>Input: pointer to precision structure </td></tr>
    <tr><td class="paramname">pba</td><td>Input: pointer to background structure (will provide the scale independent growth factor) </td></tr>
    <tr><td class="paramname">pnl</td><td>Input/Output: pointer to nonlinear structure </td></tr>
    <tr><td class="paramname">pnw</td><td>Output: pointer to nonlinear workspace </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>

</div>
</div>
<a id="a4d34e84b671d40d1ea72d195df2fc4a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d34e84b671d40d1ea72d195df2fc4a2">&#9670;&nbsp;</a></span>nonlinear_hmcode_growint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nonlinear_hmcode_growint </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="common_8h.html#structprecision">precision</a> *&#160;</td>
          <td class="paramname"><em>ppr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="background_8h.html#structbackground">background</a> *&#160;</td>
          <td class="paramname"><em>pba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnonlinear.html">nonlinear</a> *&#160;</td>
          <td class="paramname"><em>pnl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>w0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>wa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>growth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function finds the scale independent growth factor by integrating the approximate relation d(lnD)/d(lna) = Omega_m(z)^gamma by Linder &amp; Cahn 2007</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppr</td><td>Input: pointer to precision structure </td></tr>
    <tr><td class="paramname">pba</td><td>Input: pointer to background structure </td></tr>
    <tr><td class="paramname">pnl</td><td>Input: pointer to nonlinear structure </td></tr>
    <tr><td class="paramname">a</td><td>Input: scalefactor </td></tr>
    <tr><td class="paramname">w0</td><td>Input: dark energy equation of state today </td></tr>
    <tr><td class="paramname">wa</td><td>Input: dark energy equation of state varying with a: w=w0+(1-a)wa </td></tr>
    <tr><td class="paramname">growth</td><td>Output: scale independent growth factor at a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>

</div>
</div>
<a id="a4d3624e0e02a0f595a0223515b8e3897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d3624e0e02a0f595a0223515b8e3897">&#9670;&nbsp;</a></span>nonlinear_hmcode_window_nfw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nonlinear_hmcode_window_nfw </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnonlinear.html">nonlinear</a> *&#160;</td>
          <td class="paramname"><em>pnl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>window_nfw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the fourier transform of the NFW density profile.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pnl</td><td>Input: pointer to nonlinear structure </td></tr>
    <tr><td class="paramname">k</td><td>Input: wave vector </td></tr>
    <tr><td class="paramname">rv</td><td>Input: virial radius </td></tr>
    <tr><td class="paramname">c</td><td>Input: concentration = rv/rs (with scale radius rs) </td></tr>
    <tr><td class="paramname">window_nfw</td><td>Output: Window Function of the NFW profile </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>

</div>
</div>
<a id="a40f3b694b69d5d5305c5c235da4c6a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40f3b694b69d5d5305c5c235da4c6a66">&#9670;&nbsp;</a></span>nonlinear_hmcode_halomassfunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nonlinear_hmcode_halomassfunction </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>nu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>hmf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the Sheth-Tormen halo mass function (1999, MNRAS, 308, 119)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nu</td><td>Input: the <img class="formulaInl" alt="$ \nu $" src="form_66.png"/> parameter that depends on the halo mass via <img class="formulaInl" alt="$ \nu(M) = \delta_c/\sigma(M) $" src="form_193.png"/> </td></tr>
    <tr><td class="paramname">hmf</td><td>Output: Value of the halo mass function at this <img class="formulaInl" alt="$ \nu $" src="form_66.png"/> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>

</div>
</div>
<a id="aa12ee38aa9aa49f69cd0d7308fb88ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa12ee38aa9aa49f69cd0d7308fb88ec9">&#9670;&nbsp;</a></span>nonlinear_hmcode_sigma8_at_z()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nonlinear_hmcode_sigma8_at_z </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="background_8h.html#structbackground">background</a> *&#160;</td>
          <td class="paramname"><em>pba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnonlinear.html">nonlinear</a> *&#160;</td>
          <td class="paramname"><em>pnl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>sigma_8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>sigma_8_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnonlinear__workspace.html">nonlinear_workspace</a> *&#160;</td>
          <td class="paramname"><em>pnw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute sigma8(z)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pba</td><td>Input: pointer to background structure </td></tr>
    <tr><td class="paramname">pnl</td><td>Input: pointer to nonlinear structure </td></tr>
    <tr><td class="paramname">z</td><td>Input: redshift </td></tr>
    <tr><td class="paramname">sigma_8</td><td>Output: sigma8(z) </td></tr>
    <tr><td class="paramname">sigma_8_cb</td><td>Output: sigma8_cb(z) </td></tr>
    <tr><td class="paramname">pnw</td><td>Output: pointer to nonlinear workspace </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>

</div>
</div>
<a id="ab4a92da4b4ebac7ff8e0d220cc4625e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4a92da4b4ebac7ff8e0d220cc4625e1">&#9670;&nbsp;</a></span>nonlinear_hmcode_sigmadisp_at_z()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nonlinear_hmcode_sigmadisp_at_z </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="background_8h.html#structbackground">background</a> *&#160;</td>
          <td class="paramname"><em>pba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnonlinear.html">nonlinear</a> *&#160;</td>
          <td class="paramname"><em>pnl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>sigma_disp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>sigma_disp_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnonlinear__workspace.html">nonlinear_workspace</a> *&#160;</td>
          <td class="paramname"><em>pnw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute sigmadisp(z)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pba</td><td>Input: pointer to background structure </td></tr>
    <tr><td class="paramname">pnl</td><td>Input: pointer to nonlinear structure </td></tr>
    <tr><td class="paramname">z</td><td>Input: redshift </td></tr>
    <tr><td class="paramname">sigma_disp</td><td>Output: sigmadisp(z) </td></tr>
    <tr><td class="paramname">sigma_disp_cb</td><td>Output: sigmadisp_cb(z) </td></tr>
    <tr><td class="paramname">pnw</td><td>Output: pointer to nonlinear workspace </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>

</div>
</div>
<a id="acf951dc8e27339630abc1e3f9c4055d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf951dc8e27339630abc1e3f9c4055d3">&#9670;&nbsp;</a></span>nonlinear_hmcode_sigmadisp100_at_z()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nonlinear_hmcode_sigmadisp100_at_z </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="background_8h.html#structbackground">background</a> *&#160;</td>
          <td class="paramname"><em>pba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnonlinear.html">nonlinear</a> *&#160;</td>
          <td class="paramname"><em>pnl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>sigma_disp_100</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>sigma_disp_100_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnonlinear__workspace.html">nonlinear_workspace</a> *&#160;</td>
          <td class="paramname"><em>pnw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute sigmadisp100(z)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pba</td><td>Input: pointer to background structure </td></tr>
    <tr><td class="paramname">pnl</td><td>Input: pointer to nonlinear structure </td></tr>
    <tr><td class="paramname">z</td><td>Input: redshift </td></tr>
    <tr><td class="paramname">sigma_disp_100</td><td>Output: sigmadisp100(z) </td></tr>
    <tr><td class="paramname">sigma_disp_100_cb</td><td>Output: sigmadisp100_cb(z) </td></tr>
    <tr><td class="paramname">pnw</td><td>Output: pointer to nonlinear workspace </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>

</div>
</div>
<a id="a75116928f44a754e73f03503079618bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75116928f44a754e73f03503079618bc">&#9670;&nbsp;</a></span>nonlinear_hmcode_sigmaprime_at_z()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nonlinear_hmcode_sigmaprime_at_z </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="background_8h.html#structbackground">background</a> *&#160;</td>
          <td class="paramname"><em>pba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnonlinear.html">nonlinear</a> *&#160;</td>
          <td class="paramname"><em>pnl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>sigma_prime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>sigma_prime_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnonlinear__workspace.html">nonlinear_workspace</a> *&#160;</td>
          <td class="paramname"><em>pnw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute sigma'(z)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pba</td><td>Input: pointer to background structure </td></tr>
    <tr><td class="paramname">pnl</td><td>Input: pointer to nonlinear structure </td></tr>
    <tr><td class="paramname">z</td><td>Input: redshift </td></tr>
    <tr><td class="paramname">sigma_prime</td><td>Output: sigma'(z) </td></tr>
    <tr><td class="paramname">sigma_prime_cb</td><td>Output: sigma'_cb(z) </td></tr>
    <tr><td class="paramname">pnw</td><td>Output: pointer to nonlinear workspace </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the error status </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_b2f33c71d4aa5e7af42a1ca61ff5af1b.html">source</a></li><li class="navelem"><a class="el" href="nonlinear_8c.html">nonlinear.c</a></li>
    <li class="footer">Generated on Fri Jan 17 2020 13:21:14 for CLASS MANUAL by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
